#include "Session.h"

#include "IOHandle.h"
#include "SessionListener.h"
#include "TopicMan.h"
#include "rpc_man.h"

#include <jalson/jalson.h>
#include <uv.h>

#include <iostream>
#include <memory>
#include <iomanip>

#include <string.h>


#define HEADERLEN 4 /* size of uint32 */


namespace XXX {


void to_hex(const unsigned char * p, size_t size,
            std::ostream& os,
            const char* prefix = NULL,
            bool brackets = false)
{
   std::ios_base::fmtflags flags = os.flags(); // save state

   if (brackets) os << "[";

   // set up our stream for hex output
   os << std::setfill('0');
   os << std::hex;
   os << std::uppercase;
   os << std::right;

   for (size_t i = 0; i < size; ++i)
   {
      if (prefix) os << prefix;
      os << std::setw(2) << static_cast<int>(p[i]) ;
   }

   os.flags(flags);   // reset stream state

   if (brackets) os << "]";
}

/* Constructor */
Session::Session(SID s,
                 IOHandle* h,
                 SessionListener * listener,
                 TopicMan* topic_man,
                 rpc_man* rpcman)
  : m_sid(s),
    m_listener( listener ),
    m_topic_man(topic_man),
    m_io2(h),
    m_state( eWaitingLogon ),
    m_hb_intvl(30),
    m_start( m_hb_last ),
    m_hb_last(time(NULL)),
    m_buf( new char[65536] ), // TODO: make into to constant, and check during mempcy
    m_bytes_avail(0),
    m_rpcman(rpcman),
    m_is_closing(false)

{
  m_io2->m_session = this;
}

/* Destructor */
Session::~Session()
{
  delete m_buf;
}



bool Session::send_bytes(const char* s, size_t len)
{
  if (!m_is_closing)
    m_io2->send_bytes(s, len);
  return true;
}


void Session::close()
{
  m_io2->close();
}

void Session::on_close()
{
  std::cout << "Session::on_close\n";
  if (m_listener) m_listener->session_closed(*this);
}

void Session::process_message(jalson::json_value&jv)
{
  // got a wamp-lite message here

    // if (obj.type != msgpack::type::ARRAY) {
    //     throw protocol_error("invalid message structure - message is not an array");
    // }

    // wamp_message message;
    // obj.convert(&message);

    // if (message.size() < 1) {
    //     throw protocol_error("invalid message structure - missing message code");
    // }

    // if (message[0].type != msgpack::type::POSITIVE_INTEGER) {
    //     throw protocol_error("invalid message code type - not an integer");
    // }

  // TODO: need basic WAMP checking here

  if (!jv.as_array()[0].is_number()) return; // TODO: add better error handling

  int message_type = jv.as_array()[0].as_sint();

  std::cout << "Got message type " << message_type << ", msg: " <<  jv <<" \n";
  switch( message_type )
  {
    case CALL:
      process_call_message( jv );
      break;
   default:
   {}
      // TODO: need to throw a protocol error
  }
}

void Session::process_call_message(jalson::json_value& jv)
{
  jalson::json_array ja = jv.as_array();  // TODO: raise a protocol error if fails

  try
  {
    if (!m_rpcman) throw rpc_call_error(WAMP_URI_NO_SUCH_PROCEDURE);

    m_rpcman->invoke_rpc(ja);
  }
  catch(const rpc_call_error& e)
  {
  /*
    [
      ERROR,
      CALL,
      CALL.Request|id,
      Details|dict,
      Error|uri,
      Arguments|list,
      ArgumentsKw|dict
    ]

   */
    jalson::json_array msg;
    msg.push_back( ERROR );
    msg.push_back( CALL );
    msg.push_back( jv[1]);
    msg.push_back( jalson::json_object() );
    msg.push_back( e.what() );
    msg.push_back( jalson::json_array() );
    msg.push_back( jalson::json_object() );
    send_msg(msg);
  }


}

void Session::on_read(char* src, size_t len)
{
  // TODO: improve efficiency!

  memcpy(m_buf + m_bytes_avail, src, len); // TODO: check length!
  m_bytes_avail += len;
  m_buf[m_bytes_avail] = '\0';  // TODO: need this while jalson cannot take data len

  char* ptr = m_buf;

  while (m_bytes_avail)
  {
    if (m_bytes_avail < HEADERLEN) break;

    uint32_t msglen =  ntohl( *((uint32_t*) ptr) );
    if (m_bytes_avail < (HEADERLEN+msglen)) break;

    /* we have enough bytes to decode */
    ptr += HEADERLEN;



    try
    {
      jalson::json_value jv = jalson::decode(ptr);
      this->process_message( jv );
    }
    catch( const std::exception & e)
    {
      std::cout << "caught exception during message !!!! "<< e.what() << "\n";
      jalson::json_array err;
      err.push_back("wamp.runtime_error");
      err.push_back(e.what());
      this->send_msg( err, true );
    }
    catch( ... )
    {
      std::cout << "caught exception during message !!!!\n";
      jalson::json_array err;
      err.push_back("wamp.runtime_error");
      this->send_msg( err, true );

      // TODO: might have caught an error here
    }

    // TODO: only terminate the seesion for protocol error or unknow wrror

    // TODO: if caught any kind of error, then want to terminate the session here.
    // TODO: how to we send a message, and, then enable it for closing?



    ptr += msglen;
    m_bytes_avail -= (HEADERLEN + msglen);
  }

  if (m_bytes_avail && (m_buf != ptr))
  {
    memmove(m_buf, ptr, m_bytes_avail);
    m_buf[m_bytes_avail] = '\0';  // TODO: need this while jalson cannot take data len
  }




  // // TODO: detect logon, and only then subscribe to all topics
  // if (m_topic_man)
  // {
  //   std::cout << "sub all\n";
  //   m_topic_man->subscribe_all(this);
  // }

}

void Session::remove_listener()
{
  m_listener = nullptr;
}

void Session::on_timer()
{
}

void Session::call( const std::string& procedure )
{
  uint64_t request_id = ++m_request_id; // TODO: needs to be atomic

  // [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list, ArgumentsKw|dict]
  jalson::json_array json;
  json.push_back(CALL);
  json.push_back(request_id);
  json.push_back( jalson::json_object() );
  json.push_back( procedure );
  json.push_back( jalson::json_array() );
  json.push_back( jalson::json_object() );

  this->send_msg( json );

  // TODO: set up a response handle
}

void Session::send_msg(jalson::json_array& jv, bool final)
{
  if (!m_is_closing)
  {
    std::unique_ptr<char[]> msg ( jalson::encode( jv ) );

    // write message length prefix
    uint32_t msglen = htonl( strlen( msg.get() ) );
    this->send_bytes((char*)&msglen, sizeof(msglen));

    // write message
    if (final)
    {
      m_io2->send_bytes_close(msg.get(), strlen( msg.get() ));
      m_is_closing = true;
    }
    else
    {
      this->send_bytes( msg.get(), strlen( msg.get() ) );
    }
  }
}

} // namespace XXX
