#include "XXX/pre_session.h"

#include "XXX/tcp_socket.h"
#include "XXX/protocol.h"
#include "XXX/event_loop.h"
#include "XXX/log_macros.h"
#include "XXX/utils.h"
#include "XXX/kernel.h"
#include "XXX/rawsocket_protocol.h"
#include "XXX/websocket_protocol.h"
#include "XXX/http_parser.h"

#include <iomanip>

#include <string.h>
#include <unistd.h>


#define MAX_PENDING_OPEN_MS 5000

namespace XXX {


static std::atomic<uint64_t> m_next_pre_session_id(1); // start at 1, so that 0 implies invalid ID
static uint64_t generate_unique_session_id()
{
  return m_next_pre_session_id++;
}


bool pre_session::is_pending_open() const
{
  return (m_state != eClosed && m_state != eClosing);
}


int pre_session::duration_since_creation() const
{
  return (time(NULL) - m_time_create);
}


pre_session::pre_session(kernel* __kernel,
                         std::unique_ptr<tcp_socket> h,
                         on_closed_fn   __on_closed_cb,
                         on_protocol_fn protocol_cb)
  : m_state( eInit ),
    m_kernel(__kernel),
    __logger(__kernel->get_logger()),
    m_sid(generate_unique_session_id()),
    m_buf(1,1024),
    m_socket( std::move(h) ),
    m_shfut_has_closed(m_has_closed.get_future()),
    m_time_create(time(NULL)),
    m_notify_closed_cb(__on_closed_cb),
    m_protocol_cb(protocol_cb)
{
}


std::shared_ptr<pre_session> pre_session::create(kernel* k,
                                                 std::unique_ptr<tcp_socket> ioh,
                                                 on_closed_fn __on_closed_cb,
                                                 on_protocol_fn protocol_cb )
{
  std::shared_ptr<pre_session> sp(
    new pre_session(k, std::move(ioh), __on_closed_cb, protocol_cb)
    );

  sp->m_self_weak = sp;

  // can't put this initialisation step inside wamp_sesssion constructor,
  // because the shared pointer wont be created & available inside the
  // constructor
  sp->m_socket->start_read( sp.get() );

  // set up a timer to expire this session if it has not been successfully
  // opened with a maximum time duration
  std::weak_ptr<pre_session> wp = sp;
  k->get_event_loop()->dispatch(
    std::chrono::milliseconds(MAX_PENDING_OPEN_MS),
    [wp]()
    {
      if (auto sp = wp.lock())
      {
//        LOG_WARN("closing pre-session; has failed to login within time limit");
        sp->close();
      }
      return 0;
    });

  return sp;
}


pre_session::~pre_session()
{
  // note: dont log in here, just in case logger has been deleted

  // request IO closure and wait for IO thread to complete its callbacks
  // in this object, before we start deleting members
  close().wait();
}


std::shared_future<void> pre_session::close()
{
  // ANY thread

  /* Initiate the asynchronous close request. The sequence starts with a call to
   * close the underlying socket object.
   */

  if (m_state == eClosing || m_state == eClosed || m_state == eTransferedIO)
  {
    /* dont need to do anything */
  }
  else
  {
    change_state(eClosing, eClosing);
    try
    {
      m_socket->close();
    }
    catch (...) { /* ignore exceptions due to socket already closed */ }
  }
  return m_shfut_has_closed;
}


/* Called on the IO thread when the underlying tcp_socket object has closed all
 * its socket related resources (eg the tcp socket and timers).  This is the
 * last call that will be received on the IO thread.
 */
void pre_session::io_on_close()
{

  change_state(eClosed,eClosed);

  // push the final EV operation
  auto wp = m_self_weak;
  auto user_cb = m_notify_closed_cb;

  m_kernel->get_event_loop()->dispatch(
    [wp, user_cb]()
    {
      /* EV thread */

      // When called, this should be the last callback from the EV, and marks
      // the end of asynchronous events targeted at and generated by
      // self. This session is now closed.
      user_cb(wp);
    } );

  // setting the promise must be very last act in this method, since it likely
  // this object will proceed to be deleted upon this event
  m_has_closed.set_value();
}


/* Invoked on IO thread when underlying socket has recevied data.
 *
 */
void pre_session::io_on_read(char* src, size_t len)
{
  try
  {
    io_on_read_impl(src,len);
    return;
  }
  catch ( std::exception& e )
  {
    LOG_WARN("closing pre-session: " << e.what());
  }
  catch (...)
  {
    LOG_WARN("closing pre-session due to unknown exception");
  }
  this->close();
}


void pre_session::io_on_read_impl(char* src, size_t len)
{
  protocol * proto_actual = nullptr;
  protocol_builder_fn builder_fn;

  while (len)
  {
    size_t consumed = m_buf.consume(src, len);
    src += consumed;
    len -= consumed;

    // Ensure that all bytes were consumed (ie len==0), since we will need to
    // pass everything onto any protocol instance that gets created. We don't
    // have any way to handle left over data in 'src' after the concrete
    // protocol is constructed (since it will then take over socket read
    // callbacks).
    if (len)
      throw handshake_error("failed to consume all bytes read from socket");

    auto rd = m_buf.read_ptr();

    if (rd.avail() >= rawsocket_protocol::HANDSHAKE_SIZE
        && rd[0] == rawsocket_protocol::MAGIC)
    {
      rawsocket_protocol::options default_opts;

      builder_fn = [&proto_actual, default_opts](tcp_socket* io,
                                                 protocol::t_msg_cb _msg_cb)
        {
          std::unique_ptr<protocol> up (
            new rawsocket_protocol(io, _msg_cb,
                                   protocol::connection_mode::ePassive,
                                   default_opts)
            );
          proto_actual = up.get();
          return up;
        };

      break;
    }
    else if (rd.avail() >= websocket_protocol::HEADER_SIZE &&
             http_parser::is_http_get(rd.ptr(), rd.avail()))
    {
      builder_fn = [&proto_actual](tcp_socket* io,protocol::t_msg_cb _msg_cb)
        {
          std::unique_ptr<protocol> up (
            new websocket_protocol(io, _msg_cb,
                                   protocol::connection_mode::ePassive, {}));
          proto_actual = up.get();
          return up;
        };

      break;
    }
    else if (rd.avail() >= rawsocket_protocol::HANDSHAKE_SIZE)
    {
      throw handshake_error("unknown wire protocol");
    }
  }

  /* If we have identified the wire protocol, then invoke the callback object
   * which should result in the protocol instance being created.  Once created,
   * we immediately pass into it all of the bytes so far received. */
  if (builder_fn)
  {
    // this creates the concrete protocol, and a pointer to it is available
    // locally (in proto_actual)
    m_protocol_cb( builder_fn, std::move(m_socket) );

    if (proto_actual)
    {
      m_socket.reset();
      m_state = eTransferedIO;
      m_has_closed.set_value();
      proto_actual->io_on_read(m_buf.data(), m_buf.data_size());
    }
    else
      throw handshake_error("protocol identified but instance was not created");
  }

}


void pre_session::change_state(SessionState expected, SessionState next)
{
  if (m_state == eClosed) return;

  if (next == eClosed)
  {
    LOG_INFO("pre-session closed, #" << m_sid);
    m_state = eClosed;
    return;
  }

  m_state = eClosing;
}






} // namespace XXX
